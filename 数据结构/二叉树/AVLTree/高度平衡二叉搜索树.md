### AVL
    AVL树是一个高度平衡的二叉搜索树
#### AVLTree
1. 搜索二叉树
2. 要求树的左右子树的高度差不超过1，树左子树和右子树也满足高度差不超过1.
3. (当前树及所有子树都要满足前面的要求)
4. 为了方便实现，我们这里在每个节点中引入平衡因子(这个只是一种方式，并不是必须)
5. 平衡因子 = 右子树子树高度-左子树的高度\
    高度基本可以控制在O(logN)
    AVLTree增删查改的效率就是O(logN)

        二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。
        因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年发明了一种解决上述问题的方法：
        当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，
        即可降低树的高度，从而减少平均搜索长度
### 二叉搜索树
- 它的左右子树都是AVL树
- 左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1)
- 如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在O(logN)搜索时
间复杂度O(logN)
1. 按二叉搜索树的方式插入
2. 更新平衡因子
3. 如果更新完了,没有出现违反规则,则插入结束.有违反规则,则旋转处理
4. 插入的节点只会影响插入节点的祖先
#### 平衡因子
1. 每次插入一个节点,如果是父节点的左边,则`parent->_bf--;` 右边则`parent->_bf++;`
2. 更新完parent的bf,如果parent->bf == 0, 说明parent高度不变,更新结束,插入完成

解释: 说明更新前,parent的bf是1或者-1, 现在变成0, 说明把矮的那边填上了.说明我的高度不变,对上层没有影响

2. 更新完的parent的bf, 如果parent->bf == 1 或者 -1, 说明parent的高度变了,对上层有影响
3. 更新完parent的bf, 如果parent->bf == 2 或者 -2, 说明parent所在子树出现不平衡, 需要旋转处理
#### 单边旋转
##### 左旋转---左子树高,新节点插入左子树的左边---左左: 右单旋
        30(parent)

    60(subR)       h

    h+1   h
1. subR的左边给parent的右边
2. parent变成subR的左边
3. parent为根时,旋转后subR变成根
4. parent不为根的时候,旋转后subR的_parent指向prev
- 注意: 旋转节点的时候有两个特殊情况
  - 1. 旋转的subR的左子树为空
  - 2. 旋转后subR可能是根,有可能不为根
##### 右旋转---右子树高,新节点插入右子树的右边---右右: 左单旋

        30(parent)

    h       60(subR)

            h   h+1