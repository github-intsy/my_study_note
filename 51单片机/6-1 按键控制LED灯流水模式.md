### 工作模式寄存器TMOD
    不可位赋值
    7       6       5       4       3       2       1       0
    GAME    C/T     M1      M0      GAME    C/T     M1      M0


    控制为定时器1: M1->0; M0->1
    控制为定时器模式: C/T->0
    TR0单独控制: GAME->0
**不可位赋值:** 不可以为它的每一位单独赋值

控制时为`TMOD=____`

---
### TCON
    TF0 = 0;
    TF0为中断标识位, 1产生中断, 0不产生中断

    TR0 = 1;
    TR0为1, 定时器1开始工作. TR0为0, 定时器1停止工作

    定时器的范围是0~65535us.
    我们设定初始值为64535,则差1000us定时器中断,此时时间为1ms
    TH0=64535/256;  高八位取余
    TL0=64535%256;  低八位取余

#### stc
    可以直接使用工具生成对应的函数
    选择"定时器计算器"
    
    系统配置的函数需要自己生成3个参数
1. ET0 : T0的溢出中断允许位。ET0=1，允许T0中断；ET0=0禁止T0中断。
2. EA : CPU的总中断允许控制位，EA=1，CPU开放中断，EA=0，CPU屏蔽所有的中断申请。

EA的作用是使中断允许形成两级控制。即各中断源首先受EA控制;其次还受各中断源自己的中断允许控制位控制。

3. PT0=0; 较低优先级
```c
#include <REGX52.H>
unsigned int Count;

void Timer0_Init(void)		//1毫秒@12.000MHz
{
	TMOD &= 0xF0;			//设置定时器模式
	TMOD |= 0x01;			//设置定时器模式
	TL0 = 0x18;				//设置定时初始值
	TH0 = 0xFC;				//设置定时初始值
	TF0 = 0;				//清除TF0标志
	TR0 = 1;				//定时器0开始计时
	ET0 = 1;
	EA = 1;
	PT0 = 0;
}


int main()
{
	Timer0_Init();
	while(1);
	return 0;
}

void Int0_Routine() interrupt 1
{
	TL0 = 0x18;				//设置定时初始值
	TH0 = 0xFC;				//设置定时初始值
	Count++;
	if(Count >= 1000)
	{
		Count = 0;
		P2_0 = ~P2_0;
	}
}
```