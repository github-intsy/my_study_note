<details><summary>目录</summary>

- [互斥锁](#互斥锁)
  - [如何看待锁](#如何看待锁)
  - [锁在线程切换时](#锁在线程切换时)
  - [锁源码剖析](#锁源码剖析)
  - [RAII风格加锁](#raii风格加锁)
- [锁的概念](#锁的概念)
  - [死锁](#死锁)
- [进程同步](#进程同步)


</details>

## 互斥锁
```c++
库函数
#include <pthread.h>

int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                    const pthread_mutexattr_t *restrict attr);
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
/*
1. pthread_mutex_t中mutex变量就是锁本身
2. 锁是全局变量的时候, 只需要使用PTHREAD_MUTEX_INITIALIZER赋值就行
不用初始化和释放资源
3. pthread_mutex_trylock非阻塞式申请锁
*/
```
### 如何看待锁
- 加锁和解锁是多个线程串行执行的，程序变慢了
- 锁只规定互斥访问，没有规定必须让谁优先执行
- 锁就是真实的让多个执行流进行竞争的结果
  - 所以让当前进程做别的事情，就可以让其他线程拥有争抢能力
- pthread_mutex_lock\pthread_mutex_unlock加锁的过程中必须是安全的, 加锁其实是原子的
- 加锁过程如果暂时不成功，该进程会被阻塞
- 谁持有锁，谁进入临界区
### 锁在线程切换时
- 如果线程1，申请锁成功，进入临界资源，正在访问临界资源期间，其他线程在做什么？
  - 阻塞等待
- 如果线程1，申请锁成功，进入临界资源，正在访问临界资源期间，可不可以被切换？
  - 绝对可以
`当持有锁的线程被切走的时候，是抱着锁被切走的，即使自己被切走了，其他线程依旧无法申请锁成功，也便无法向后执行`

所以对于其他线程而言，有意义的锁的状态，无非两种
1. 申请锁前
2. 释放锁后

- 站在其他线程的角度，看待当前线程持有锁的过程，就是原子的。
- 要尽可能的保证临界区加锁的粒度`代码段`最小
- 加锁是个人行为，要加锁就必须都加

### 锁源码剖析
- CPU内寄存器只有一套被所有执行流共享
- CPU内寄存器的内容，是每个执行流私有的，运行时执行上下文
```
lock:
  movb $0, %al
  //%al是CPU的寄存器, %0是当前进程的上下文
  xchgb %al, mutex
  if(al寄存器的内容 > 0){
    return 0;
  }else
    挂起等待
  goto lock;
unlock:
  movb $1, mutex
  唤醒等待Mutex的线程
  return 0;
```
汇编中, exchange指令只用一条指令就能交换数据

交换的本质：共享的数据，交换到我的上下文中。

### RAII风格加锁
```c++
class Mutex
{
public:
    Mutex(pthread_mutex_t* mutex = nullptr) :mutex_(mutex)
    {}
    ~Mutex()
    {}
    void lock()
    {
        if(mutex_) pthread_mutex_lock(mutex_);
    }
void unlock()
{
    if(mutex_) pthread_mutex_unlock(mutex_);                                                                
    }
private:
    pthread_mutex_t* mutex_;
};
class LockGuard
{
public:
    LockGuard(pthread_mutex_t* mutex) :mutex_(mutex)
    {
        mutex_.lock();
    }
    ~LockGuard()
    {
        mutex_.unlock();
    }
 private:
    Mutex mutex_;
};
```
在需要加锁的情况下直接使用`LockGuard lo(&mut)`创建对象, 会自动加锁, 解锁

## 锁的概念
### 死锁
当两个进程互相持有自己的锁，而且还要对方的锁的时候，进而可能导致多执行流互相等待对方资源而导致代码无法推进的现象
|死锁的四个必要条件|解释|
|:---:|:---:|
|互斥|锁具有互斥特性|
|请求与保持|不释放自己资源同时, 请求别的资源|
|不剥夺|只能请求, 不能抢占|
|环路等待条件|请求资源线路形成一个闭环|

- a申请的锁可以让b释放

## 进程同步
一个进程长时间访问资源导致其他进程长时间访问不到资源的状态, 叫做`饥饿状态`

在数据安全的情况下, 让一些进程按照一定的顺序进行访问, 叫做`进程同步`