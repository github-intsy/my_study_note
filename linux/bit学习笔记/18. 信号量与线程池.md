<details><summary>目录</summary>

- [信号量引入线程](#信号量引入线程)
- [引入信号量概念](#引入信号量概念)
  - [什么是信号量？](#什么是信号量)
  - [环形队列](#环形队列)

</details>

## 信号量引入线程
1. 一个线程，在操作临界资源的时候，临界资源必须是满足条件的
2. 可是，公共资源是否，满足生产或者消费条件，我们无法直接得知
3. 只能先加锁，再检测，再操作，再解锁`检测的本质就是在访问临界资源`

## 引入信号量概念
### 什么是信号量？
>信号量本质是一把计数器，用来衡量临界资源中资源数量是多少的计数器，信号量本身就是公共资源

只要拥有信号量，就在未来拥有临界资源的一部分。
>信号量的本质就是：对临界资源中特定小块资源的预定

- 申请成功，就一定有你的资源
- 申请失败，就说明条件不就绪，只能等
  - 这样，就不需要进入临界区进行资源判断了

| 操作  | 解释                                |
| ----- | ----------------------------------- |
| sem-- | 申请资源, 保证操作的原子性, 是P操作 |
| sem++ | 归还资源, 保证原子性, 是V操作       |
| 总结  | 信号量核心操作, 就是PV原语          |
```c++
//初始化信号量
#include<semaohore.h>
int sem_init(sem_t* sem, int pshared, unsigned int value);
参数:
    pshared: 0表示线程共享, 非零表示线程共享
    value: 信号量初始值

//销毁信号量
int sem_destroy(sem_t*sem);

//等待信号量
功能: 等待信号量, 会将信号量的值减1
int sem_wait(sem_t *sem); //P()

//发布信号量
功能: 发布信号量, 表示资源使用完毕, 可以归还资源了, 将信号量加1
int sem_post(sem_t *sem); //V()
```
### 环形队列
信号量是用来衡量资源中数量的
1. 对生产者而言，看中什么？队列中的剩余空间--空间资源定义一个信号量
2. 对消费者而言，看中的是什么？放入队列中的数据！--数据资源定义一个信号量
3. 适合信号量的场景，支持并发访问整片区域，独享其中一块区域

```c++
 template<class T>
class RingQueue
{
private:                                                             
    void P(sem_t& sem)
    {
        int n = sem_wait(&sem);
        assert(n==0);
        (void)n;
    }
    void V(sem_t& sem)
    {
        int n = sem_post(&sem);
        assert(n==0);
        (void)n;
    }
public:
    RingQueue(const int& cap = gcap): _queue(cap), _cap(cap)
    {
        int n = sem_init(&_spaceSem, 0, _cap);
        assert(n == 0);
        n = sem_init(&_dataSem, 0, 0);
        assert(n==0);
        _productorStep = _consumerStep = 0;//刚开始消费者和生产者相同位置
        //队列满的时候消费者和生产者一个位置
        n = pthread_mutex_init(&_productorMutex, nullptr);
        assert(n==0);
        n = pthread_mutex_init(&_consumerMutex, nullptr);
        assert(n==0);
        (void)n;
        }
        //生产者线程
    void push(const T& data)
    {
        P(_spaceSem);
        pthread_mutex_lock(&_productorMutex);
         _queue[_productorStep++] = data;
        _productorStep %= _cap;
        pthread_mutex_unlock(&_productorMutex);
        V(_dataSem);
    }
    //消费者线程
    void pop(T* out)
    {
        P(_dataSem);
        pthread_mutex_lock(&_consumerMutex);
        *out = _queue[_consumerStep++];
        _consumerStep %= _cap;
        pthread_mutex_unlock(&_consumerMutex);
        V(_spaceSem);
    }
    ~RingQueue()
    {                                                           
        sem_destroy(&_spaceSem);
        sem_destroy(&_dataSem);
    }
private:
    sem_t _spaceSem;//生产者 看中剩余空间
    sem_t _dataSem;//消费者看中剩余资源
    std::vector<T> _queue;//环形队列
    int _productorStep;//指向生产者当前位置
    int _consumerStep;//指向消费当前位置
    int _cap;//环形队列最大容量
    pthread_mutex_t _productorMutex;
    pthread_mutex_t _consumerMutex;
}; 
```
>1. `sem_wait()`函数就是P操作
>2. `sem_post()`函数就是V操作
>3. 构造函数初始化信号量和互斥锁
>4. 析构函数释放信号量和互斥锁