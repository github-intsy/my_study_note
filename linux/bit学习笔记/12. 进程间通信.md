<details><summary>目录</summary>

- [什么是通信?](#什么是通信)
- [为什么要通信？](#为什么要通信)
- [匿名管道](#匿名管道)
- [管道的特征](#管道的特征)
- [命名管道](#命名管道)


</details>

## 什么是通信?
- 数据传输：一个进程需要将他的数据传送给另一个进程
- 资源共享：多个进程之间共享相同的资源
- 通知事件：一个进程需要向另一个或一组进程发送消息
- 进程控制：有些进程希望完全控制另一个进程的执行（比如Debug进程），此时控制进程希望能够拦截另外一个进程的所有陷入和异常，并能够即时知道它的状态改变

## 为什么要通信？
有时候我们需要多个进程协同
`cat file | grep 'Hello'`

## 匿名管道
    父子进程间进行通信, 通过对一个文件读写通信
    父子进程默认一个只读一个只写
    类似管道,文件开放两个端口, 两个进程分别占用一个进行读或写
    管道是单向通信的

- 当管道中没有了数据, 读端默认阻塞当前正在读的进程\
  如果没数据写入, 最后一次读取会**返回0**, 之后进入阻塞
- 管道是一个固定大小的文件, 当文件写满时, 再写有可能会将其原有的数据**覆盖**, 此时**不能**再写入数据.\
  写端写满阻塞,等待读端读取数据后再写入
- 读取管道数据只能读取**指定大小**的数据, 管道内数据**小于**指定大小就**全部读取**
- 读端先关闭, OS会终止写端, 会给写进程发送信号

## 管道的特征
1. 管道的生命周期--进程
2. 管道可以用来进行具有血缘关系的进程之间进行通信, 常用与父子通信
3. 管道是面向字节流的(网络)
4. 半双工--单向通信
5. 互斥与同步机制 -- 对共享资源进行保护的方案

## 命名管道
`assert`在**debug**版本下是生效的, 但是在**release**版本下被编译器移除。
```cpp
void removefile(const std::string &path)
{
    int n = unlink(path.c_str());
    assert(n == 0); //debug生效, release被移除
    (void)n; //保证该变量不管是debug还是release下都会被使用, 避免warring提示
}
```
**口诀：** 确定代码用`assert`, 不确定用`if判断`

管道文件中，读端使用`open`打开文件时会阻塞在`open`中。直到再来一个进程同时打开这个文件，才能继续执行后续内容