<details><summary>目录</summary>

- [什么是线程?](#什么是线程)
	- [如何看待地址空间和页表](#如何看待地址空间和页表)
	- [页表结构](#页表结构)
	- [概念](#概念)
	- [LWP](#lwp)
	- [函数](#函数)
	- [资源共享](#资源共享)
- [资源损耗问题](#资源损耗问题)
	- [异常处理](#异常处理)
- [线程控制](#线程控制)
	- [线程创建](#线程创建)
	- [线程终止](#线程终止)
	- [线程等待](#线程等待)
	- [线程取消](#线程取消)
- [线程分离](#线程分离)
- [线程id来源](#线程id来源)
	- [线程的局部存储](#线程的局部存储)
- [线程切换](#线程切换)
- [问题与细节](#问题与细节)

</details>

## 什么是线程?
### 如何看待地址空间和页表
1. 地址空间是进程能看到的资源窗口
2. 页表决定, 进程真正拥有资源的情况.
3. 合理的对地址空间+页表进行资源划分, 我们就可以对一个进程的所有资源进行分类

- 磁盘中可执行文件等所有文件, 都是以4KB为单位划分的, 称为**页帧**
- 物理内存将文件大小划分为4KB一个单位, 称为**页框**

### 页表结构
将32位的虚拟地址空间`0000 0000 0000 0000 0000 0000 0000 0000`划分为`10, 10, 12`的位数\
对应着`页目录` `页表项(二级页表)` `页帧中的偏移量`\
地址存储是由高到低的
|位数|内容|
|---|---|
|前10位bit|转化为整数变为对应页表项的下标|
|中间10位bit|也存在$2^{10}$个下标, 存放指定**页框**的起始物理地址|
|后12位bit|代表存放的数据在**页帧**中的偏移量|

int存储数据根据地址找到页内的偏移量对应的起始地址,然后向后查找4个字节的数据\
OS只为需要访问对应物理内存的时候, 创建对应的页表和映射关系

### 概念
什么叫做进程?\
内核视角: 承担分配系统资源的基本实体
- 进程原来的概念: 内核数据结构 + 进程对应的代码和数据
- 进程现在的概念: 占用系统的很多资源(CPU、寄存器和IO设备等)
- 线程是CPU调度的基本单位

如何看待之前学习进程时，对应的进程概念呢？和今天的冲突吗？
- 进程都是承担系统资源的基本实体，不过内部只有一个执行流
- 一个进程内部可以有多个执行流
- 线程是进程内的一个执行流
- 线程在进程内部运行, 线程在进程的地址空间内运行。拥有该进程的一部分资源

1. Linux内核中有没有真正意义的线程？没有，linux是用进程PCB模拟线程的，是一种完全属于自己的一套线程方案
2. 站在CPU的视角，每一个PCB，都可以称之为轻量级进程
3. Linux线程是CPU调度的基本单位，而进程是承担分配系统资源的基本单位
4. 进程用来整体申请资源，线程用来伸手向进程要资源
5. Linux中没有真正意义的线程
6. 好处是什么？简单，维护成本大大降低--可靠高效

如果OS只认线程，用户（程序员）也只认线程\
Linux便无法直接提供创建线程的系统调用接口，而只能给我们提供创建轻量级进程的接口\
这个接口就是`clone`

因此, 我们只能使用第三方集成的库, 来创建线程使用它`pthread`

任何linux操作系统, 都必须默认携带这个库, 原生线程库

### LWP
light weight process: 轻量级进程ID

与PID相同的进程叫做主线程, 不同的叫做新线程

CPU调度的时候, 是以LWP为标识符表示一个执行流的

### 函数
|函数名|参数|作用|返回值|
|---|---|---|---|
|pthread_creat|pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);|为当前进程创建一个线程, 需要使用`-lpthread`链接库|成功0, 失败返回错误码|

### 资源共享
- 线程一旦被创建, 几乎所有的资源都是被所有线程共享的
- 线程也一定要有自己私有的资源, 什么资源应该是私有的?
  - PCB属性私有
  - 一定要有私有的上下文结构
  - 每一个线程都要有自己独立的栈结构

## 资源损耗问题
与进程之间的切换相比, 线程之间的切换需要操作系统做的工作要少得多
1. 进程切换：`切换页表` `虚拟地址空间` `切换PCB` `上下文切换`
2. 线程切换：`切换PCB` `上下文切换`
3. 线程切换cache不用太更新，但是进程切换，全部更新

CPU中存在cache高速缓冲区，里面存放着当前进程从内存调用到寄存器中的数据，根据**局部性原理**，将访问数据周边的数据一起加载到cache中，可以提高数据命中率，提高访问效率。\
如果频繁切换进程，会频繁刷新cache中的数据，cache加载数据需要消耗时间。所以，进程切换比线程切换做的工作要多的多

**linux中的执行流, 统称为轻量级进程**

以前学到的进程是：一个进程，里面只有一个执行流

###  异常处理
一个线程如果出现异常，会影响线程（健壮性或鲁棒性较差），为什么？

因为信号被称为进程信号，信号是整体发给进程的

进程被回收后，由于线程是依赖进程的资源运行的，所以当进程资源被回收后，线程也会被结束

## 线程控制
### 线程创建
pthread函数出错时不会设置全局变量errno。而是将错误码返回\
如果设置的是全局变量，多个线程都去访问。从而会产生因缺乏访问控制而带来的问题

```c++
for(int i = 0; i < 10; ++i)
{
	pthread_t tid;
	char namebuffer[64];
	snprintf(namebuffer, sizeof(namebuffer), "%s:%d", "thread", i);
	pthread_create(&tid, nullptr, start_routine, namebuffer);
}
```
如果一次性创建多个线程，每次创建线程的执行顺序是随机的，如果主线程先运行，那么主线程直接对namebuffer数据写入，而`pthread_creat`函数，只是将namebuffer的起始地址传递给新线程，缓冲区中的数据被新写入的数据覆盖，最后每个线程只能拿到最新的id，也就是9

创建线程时附加的函数，是可重入状态，也就是可重入函数
- 在函数内定义的变量，都叫做局部变量，具有临时性。在多线程情况下同样适用
- 其实每一个线程都有自己独立的栈结构

### 线程终止
1. 线程函数结束，return的时候，线程就算终止了
2. exit不能终止线程，只能用来终止进程，任何一个执行流调用exit都会让整个进程退出
3. pthread_exit退出当前线程

### 线程等待
每一个用户级线程对应每一个内核级线程LWP，线程退出时对应的PCB也没有被释放，也会造成类似于僵尸进程的问题`内存泄漏`
1. 回收新线程的退出信息（可以不关心，但是必须回收资源）
2. 回收新线程对应的PCB等内核资源，防止内核泄漏
3. 使用`pthread_join()`函数阻塞式等待线程资源


```c++
#include<pthread.h>
int pthread_join(pthread_t thread, void** retval);
//输出型参数, 用来获取线程函数结束时, 返回的退出结果

void pthread_exit(void* retval);
```

- 线程函数会将**返回值**返回到pthread的库中
- pthread_join默认函数调用会成功，异常是进程该考虑的问题

用函数传参,如果两端类型相同, 只能是传值传参\
只有两端所处的指针等级不同, 才能传址传参
### 线程取消
线程可以被取消，线程要被取消的前提就是，线程必须要跑起来
```c++
#include<pthread.h>
int pthread_cancel(pthread_t thread);
取消特定进程
```
一个线程如果被取消，退出码就是-1，`PTHREAD_CANCELED`

一般都是用主线程控制新线程的

任何语言,如果要在linux中实现多线程, 必定要调用pthread库

c++11中的多线程, 在linux环境中, 本质上是对pthread库的封装

## 线程分离
```c++
#include<pthread.h>
pthread_t pthread_self(void);
谁调用这个函数, 就返回谁的线程id

int pthread_detach(pthread_t thread);
分离一个线程

//pthread_detach(pthread_self);设置自己为分离状态
```
- 设置线程分离后不需要主线程join该线程, OS自动回收资源
- 一个线程默认是joinable的，如果设置了分离状态，不能进行等待
- 一个线程被join之前，一定要保证该线程已经被分离了


## 线程id来源
- Linux方案：用户级线程，用户关心的属性在库中，内核提供线程执行流的调度
- Linux用户级线程：内核轻量级进程 = 1：1

linux中只有轻量级进程概念，用户只认识线程，linux就为用户和os之间创建了一个线程库

一旦进程用了这个库，就会将这个库加载到进程的地址空间当中

mmap区是库和磁盘文件的映射区域

所以线程创建返回的id就是**线程库**当中在**共享区**的**存储地址**

线程返回值会自动放到对应线程id的存储空间中

- 每个线程都有其对应的私有栈，这个私有栈存储在线程库的共享区，也就是线程的TCB中
- 线程容量可以调整（扩容）但是不建议，因为你不清楚默认量的大小

### 线程的局部存储
添加`__thread`可以将一个内置类型设置为线程局部存储
```c++
__thread int g_val = 100;
```
这样可以让一个全局变量给每个线程都拷贝一份到线程局部存储中.

.hpp文件可以将类的声明和类的方法实现放在一起, 

- 类中函数默认存在this指针指向类中的成员变量和函数。
- 使用static静态函数，就不会添加默认参数this指针
- 静态函数不能调用成员变量和函数

## 线程切换
多个线程交叉执行本质:就是让调度器尽可能的频繁发生线程调度与切换

线程一般在什么时候发生切换呢?时间片到了，来了更高优先级的线程，线程等待的时候。

线程是在什么时候检测上面的问题呢?从内核态返回用户态的时候，线程要对调度状态进行检测，如果可以，就直接发生线程切换	

**判断的本质逻辑**：
1. 读取内存数据到CPU内的寄存器中
2. 进行逻辑判断
3. 一个if判断同一时刻，只能有一个线程判断
   1. 从内存读取数据到CPU寄存器中（寄存器中的数据叫做当前线程的上下文）
   2. 从寄存器中让CPU进行对应的算逻运算
   3. 写回新的结果到内存中变量的位置
4. 多线程对一个全局变量进行修改，会出现问题
   1. 多个执行流进行安全访问的共享资源 -临界资源
   2. 我们把多个执行流中，访问临界资源的代码--临界区--往往是线程代码的很小的一部分
   3. 想让多个线程串行访问共享资源--互斥
   4. 对一个资源进行访问的时候，要么不做，要么做完 -- 原子性， 不是原子性的情况 -- 一个对资源进行的操作，如果只用一条汇编就能完成

## 问题与细节
>1. `pthread_create`函数的回调函数未执行，因为主线程执行速度过快，到时回调函数未执行就结束进程导致。\
可以使用`pthread_join`阻塞等待释放线程资源，如果使用`pthread_detach`将自己分离，如果主线程内容太少，可以使用`sleep(1)`来观察现象。