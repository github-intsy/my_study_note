<details><summary>目录</summary>

- [什么是线程?](#什么是线程)
  - [如何看待地址空间和页表](#如何看待地址空间和页表)
  - [页表结构](#页表结构)
  - [概念](#概念)
  - [LWP](#lwp)
  - [函数](#函数)
  - [资源共享](#资源共享)
- [资源损耗问题](#资源损耗问题)

</details>

## 什么是线程?
### 如何看待地址空间和页表
1. 地址空间是进程能看到的资源窗口
2. 页表决定, 进程真正拥有资源的情况.
3. 合理的对地址空间+页表进行资源划分, 我们就可以对一个进程的所有资源进行分类

- 磁盘中可执行文件等所有文件, 都是以4KB为单位划分的, 称为**页帧**
- 物理内存将文件大小划分为4KB一个单位, 称为**页框**

### 页表结构
将32位的虚拟地址空间`0000 0000 0000 0000 0000 0000 0000 0000`划分为`10, 10, 12`的位数\
对应着`页目录` `页表项(二级页表)` `页帧中的偏移量`\
地址存储是由高到低的
|位数|内容|
|---|---|
|前10位bit|转化为整数变为对应页表项的下标|
|中间10位bit|也存在$2^{10}$个下标, 存放指定**页框**的起始物理地址|
|后12位bit|代表存放的数据在**页帧**中的偏移量|

int存储数据根据地址找到页内的偏移量对应的起始地址,然后向后查找4个字节的数据\
OS只为需要访问对应物理内存的时候, 创建对应的页表和映射关系

### 概念
什么叫做进程?\
内核视角: 承担分配系统资源的基本实体
- 进程原来的概念: 内核数据结构 + 进程对应的代码和数据
- 进程现在的概念: 占用系统的很多资源(CPU、寄存器和IO设备等)
- 线程是CPU调度的基本单位

如何看待之前学习进程时，对应的进程概念呢？和今天的冲突吗？
- 进程都是承担系统资源的基本实体，不过内部只有一个执行流
- 一个进程内部可以有多个执行流
- 线程是进程内的一个执行流
- 线程在进程内部运行, 线程在进程的地址空间内运行。拥有该进程的一部分资源

1. Linux内核中有没有真正意义的线程？没有，linux是用进程PCB模拟线程的，是一种完全属于自己的一套线程方案
2. 站在CPU的视角，每一个PCB，都可以称之为轻量级进程
3. Linux线程是CPU调度的基本单位，而进程是承担分配系统资源的基本单位
4. 进程用来整体申请资源，线程用来伸手向进程要资源
5. Linux中没有真正意义的线程
6. 好处是什么？简单，维护成本大大降低--可靠高效

如果OS只认线程，用户（程序员）也只认线程\
Linux便无法直接提供创建线程的系统调用接口，而只能给我们提供创建轻量级进程的接口

因此, 我们只能使用第三方集成的库, 来创建线程使用它`pthread`

任何linux操作系统, 都必须默认携带这个库, 原生线程库

### LWP
light weight process: 轻量级进程ID

与PID相同的进程叫做主线程, 不同的叫做新线程

CPU调度的时候, 是以LWP为标识符表示一个执行流的

### 函数
|函数名|参数|作用|返回值|
|---|---|---|---|
|pthread_creat|pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);|为当前进程创建一个线程, 需要使用`-lpthread`链接库|成功0, 失败返回错误码|

### 资源共享
- 线程一旦被创建, 几乎所有的资源都是被所有线程共享的
- 线程也一定要有自己私有的资源, 什么资源应该是私有的?
  - PCB属性私有
  - 一定要有私有的上下文结构
  - 每一个线程都要有自己独立的栈结构

## 资源损耗问题
与进程之间的切换相比, 线程之间的切换需要操作系统做的工作要少得多
1. 进程切换：`切换页表` `虚拟地址空间` `切换PCB` `上下文切换`
2. 线程切换：`切换PCB` `上下文切换`
3. 线程切换cache不用太更新，但是进程切换，全部更新

PCU中存在cache高速缓冲区，里面存放着当前进程从内存调用到寄存器中的数据，根据连续访问原则，将访问数据周边的数据一起加载到cache中，可以提高数据命中率，提高访问效率。\
如果频繁切换进程，会频繁刷新cache中的数据，cache加载数据需要消耗时间。所以，进程切换比线程切换做的工作要多的多