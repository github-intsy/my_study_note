<details> <summary>目录</summary>

- [函数归纳](#函数归纳)
- [进程状态](#进程状态)
- [僵尸资源](#僵尸资源)
- [孤儿进程](#孤儿进程)
- [进程优先级](#进程优先级)
- [进程切换](#进程切换)

</details>

## 函数归纳
|函数名|作用|
|---|---|
|#include<unistd.h>|系统命令头文件,可以使用sleep等函数|
|#include<sys/types.h>|包含getpid等函数|
|getpid()|获得当前进程号|
|getppid()|获得当前进程的父进程号|
|fork()|创建一个子进程<li>pid_t类型数据接收<li>父进程返回子进程进程号, 子进程返回0|

什么是进程?\
进程=内核数据结构+进程对应的磁盘代码

## 进程状态
进程只要在运行队列中,就会是在`运行状态`

## 僵尸资源
子进程退出,父进程依然运行时,子进程为僵尸进程

也就是进程结束时, 由于父进程没结束,操作系统不会回收资源,此时用户回收资源, 此时子进程已经死亡, 操作系统暂时不回收资源. 这个进程就叫做僵尸进程

## 孤儿进程
1. 这种现象一定存在
2. 子进程会被操作系统领养 `1号进程`
3. 为什么这么干?如果子进程退出,对应的僵尸进程,便没有人能回收了
4. 被领养的进程--孤儿进程

```
带+号的进程是前台进程, 不带+号的进程是后台进程
前台进程能够使用ctrl+z结束, 后台进程只能通过命令行的形式来杀死
```
如果前台进程创建的子进程变成孤儿进程了,那么该进程就会变成后台进程

## 进程优先级
最终优先级=旧优先级`pri`+ni`nice`

pri的数字越小,优先级越大
```
使用top指令修改优先级
1. top
2. 输入需要修改的pid值
3. 输入修改的pri值
```
nice的调整范围是$[-20,19]$

## 进程切换
CPU三种动作
1. 取指令
2. 分析指令
3. 执行指令

        取一个cpu内寄存器存在当前进程PCB等信息
        用另一个寄存器(pc/eip)存放当前正在执行指令的下一条指令的地址

        当我们的进程在运行时,一定会产生非常多的临时数据,这份数据属于当前进程

        CPU内部虽然只是一套寄存器硬件,但是寄存器里面保存的数据,是属于当前进程的

        寄存器!=当前进程

进程在运行时，占有CPU，但是进程不是一直占有到进程结束`所以进程在运行的时候, 都有自己的时间片`\
当进程被切换的时候,将所有临时数据保存到**PCB**中,然后将进程切换

- 进程在切换的时候,要进行进程的上下文保护
- 当进程在恢复运行的时候,要进行上下文的恢复

**在任何时刻,CPU内的寄存器里面的数据,看起来是在大家都能看到的寄存器上\
但是,寄存器内的数据,只属于当前运行的进程!\
寄存器被所有进程共享,寄存器内的数据,是每个进程各自私有的--上下文数据**

