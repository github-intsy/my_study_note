<details><summary>目录</summary>

- [计算机编译的四个阶段:](#计算机编译的四个阶段)
- [bash层指令](#bash层指令)
- [动静态链接库](#动静态链接库)

</details>

## 计算机编译的四个阶段:
1. 预处理 ->头文件的展开/宏替换/条件编译/去掉注释\
list.i  test.i
2. 编译 ->检查语法,生产汇编代码\
list.s  test.s
3. 汇编 ->汇编代码转化成二进制的机器码\
转换成`01`的数据(不可执行),转换为`二进制目标文件`(二进制可重定位目标文件)\
list.o  test.o                         
1. 编译 ->将两个目标文件链接到一起\
a.out

        头文件含义:
        1.写代码
        2.支持代码自动补齐

## bash层指令
|指令|含义|
|---|---|
|gcc -E test.c -o test.i|<li>-E将程序运行结果停止在`预处理`<li>-o指明形成的临时文件`名称`|
|gcc -S test.i -o test.s|<li>-S将c代码转化成汇编, 然后形成文件|
|gcc -c test.s -o test.o|<li>-c将汇编代码转化成二进制代码|
|gcc test.o|<li>将gcc和二进制代码链接起来|

## 动静态链接库
- 静态库是指编译链接时,把库文件的代码全部加入到可执行文件中,因此生成的文件比较大,但在运行时也就不再需要库文件了。其后缀名一般为“.a”
- 动态库与之相反,在编译链接时并没有把库文件的代码加入到可执行文件中,而是在程序执行时由运行时链接文件加载库,这样可以节省系统的开销。动态库一般后缀名为“.so”,如前面所述的 libc.so.6 就是动态库。gcc 在编译时默认使用动态库。完成了链接之后,gcc 就可以生成可执行文件,如下所示。 `gcc hello.o –o hello`

|类型|优势|缺陷|
|---|---|---|
|动态链接|体积小, 占用资源少||
|静态链接|不受库升级或者删除的影响|形成的可执行程序体积太大|

|指令|作用|
|---|---|
|file a.out|确定`a.out`文件的类型|
|ldd a.out|查看可执行程序依赖的动态库列表|

    在linux下库的命名
    动态库:
    libXXXXXX.so

    静态库:
    libXXXXXX.a

    去掉前缀和后缀,剩下的就是库名称

- linux系统中大部分指令也都是使用c语言写的,是动态库, 库只有一份,不会出现重复的库代码.
- 所以动态库也叫做共享库
- 静态链接只能拷贝系统中存在的静态库
- 动态库系统自带。静态库如果不存在，需要自己安装