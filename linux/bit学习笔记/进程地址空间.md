
## 本质
进程地址空间的本质是一个内核的数据结构

1. 地址空间描述的基本空间大小单位是字节
2. 32位计算机下->最多能够生成$2^{32}$个地址
3. $2^{32}$个地址, 每个地址是一个字节。地址空间范围是大约有$4GB$的**空间范围**
4. 每个字节都要有唯一的地址`只需要保证唯一性`
5. 为了保证唯一性, 只需要使用32位的01数字标识地址

## 地址空间
操作系统给每个进程分配了地址空间

内核对进程的地址空间进行划分，每部分对应不同的区域\
比如：`0x1111 1111-0x1211 1111`, 对应着**代码区**

区域之间留有一小部分的空白区域, 称为**缓冲区**，用来保证不同区域之间的数据不会"越界"

区域扩大就是修改各个区域定义的end或start值\
使用malloc

因为进程具有独立性，一个进程对被共享的数据做修改，如果影响了其他进程，不能称之为独立性\
所以,当父进程或者子进程尝试将共享数据资源进行修改时, OS为了保证进程独立性,就会给要修改数据的进程重新在物理内存中开辟一个空间,并修改页表的映射关系


可执行程序里面，在没有被加载到内存中的时候，其实是存在地址的

- 可执行文件在磁盘中时，各个区域就已经划分好了
- 代码中的各种编址都是指虚拟地址，这些地址是代码在编译的时候就已经生成的
## 虚拟地址和物理地址
1. 在磁盘中的可执行文件中存在代码区\
在代码区中**函数有着其对应的虚拟地址**
2. 将可执行文件加载到内存上后，每个函数有着对应的物理地址在内存中
3. **操作系统**将**可执行文件**的虚拟地址放到**进程地址空间**中，并设置进**CPU的寄存器**里

        CPU通过代码区起始地址读取，通过页表映射
        找到内存中存储的main函数的代码
        并将main函数的代码读取到CPU中执行
        
        调用其他函数时，读取代码区中的虚拟地址
        继续重复上述步骤获取内存中的代码指令到CPU中

        tesk_struct就是PCB
        mm_struct就是虚拟地址空间

## 为什么存在物理地址？
1. 如果让进程之间访问物理内存，万一进程越界非法操作呢？非常不安全
2. 进程空间的存在，可以更方便的进行进程和进程的数据代码的解耦，保证了进程独立性这样的特征
3. 让进程以统一的视角，来看待进程对应的代码和数据等各个区域，方便使用\
   编译器也以同一的视角来进行编译代码\
   规则是一样的，编完即可直接使用