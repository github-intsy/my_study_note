### 四种最短路算法
- 单源最短路
  - 所有边权都是正数
    - 朴素Dijkstra算法`O(N^2)`
    - 堆优化版的Dijkstra算法`O(mlogn)`
  - 存在负权边
    - Bellman-Ford算法`O(nm)`
    - SPFA算法`一般O(m)`, `最坏O(nm)`
- 多源汇最短路
  - Floyd算法`O(n^3)`
---
#### 邻接矩阵和邻接表
- 稠密图用邻接矩阵储存
  - 邻接矩阵一般使用二维数组进行存储
  - `g[a][b]`存储的是`a到b的信息`, 如果有权重`g[a][b]`存储的就是权重
  - 如果有重边就存储短的一条
- 稀疏图用邻接表存储
  - 邻接表存储多条链表,每条链表存储的就是当前这个点能够走到哪个点

### dijkstra算法(朴素算法)
- `dist`数组是用来记录从源点1到每个顶点的当前最短距离的数组。初始时，将所有顶点的距离设置为一个较大的值（这里使用0x3f3f3f3f）表示无穷大。然后将源点1的距离设置为0，表示自身到自身的距离为0
#### 模板
```c++
int dijkstra()
{
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	for (int i = 0; i < n; ++i)
	{
		int t = -1;
		for (int j = 1; j <= n; ++j)
			if (!st[j] && (t == -1 || dist[t] > dist[j]))//在所有距离没有确定的点中,找到dist最小的点
				t = j;
		st[t] = true;//表明确定该点的距离最小
		for (int j = 1; j <= n; ++j)
			dist[j] = min(dist[j], dist[t] + g[t][j]);
		//判断是原点到j的距离小, 还是原点到t + t到j的距离小
	}
	if (dist[n] == 0x3f3f3f3f) return -1;//没找到
	return dist[n];//找到n的最短路径
}
```
#### dijstra算法(堆优化版)
- 使用优先队列来维护点中的距离
- 第一次放进起点
- 每次取堆顶的元素(最小),
  - 如果这个点是被跟新过,就说明这个点是冗余备份,continue出栈顶即可
  - 否则就用这个点来跟新其他所有点,如果跟新成功就把这个点放进队列中
```c++
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({ 0,1 });
while (heap.size())
{
  auto t = heap.top();
  heap.pop();
  int ver = t.second, distance = t.first;
  if (st[ver]) continue;
  for (int i = h[ver]; i != -1; i = ne[i])
  {
    int j = e[i];
    if (dist[j] > distance + w[i])
    {
      dist[j] = distance + w[i];
      heap.push({ dist[j], j });
    }
  }
}
if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
```
#### Bellman-forf算法
- 单源具有负权值的路径
- 规定最多使用k条边达到x点
  - 只能先拷贝该层的结果,然后使用上层的边来进行判断
- 最后判断是`dist[n] > 0x3f3f3f3f / 2`
  - 因为有可能两个节点, 1都到不了, 但是权值优势负数, 所以可能造成`正无穷 - 2`的现象
```c++
int ballman_ford()
{
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	for (int i = 0; i < k; ++i)//要求的k条边
	{
		memcpy(backup, dist, sizeof dist);//保留上一层的结果
		for(int j = 0; j < m; ++j)//边的数量m
		{
			int a = edge[j].a, b = edge[j].b, w = edge[j].w;//将a点,b点,权值储存到结构体数组中
			dist[b] = dist[a] + w;
		}
	}
}
```
#### spfa算法
- 时间复杂度O(m), 最坏情况O(nm)
```c++
int spfa()
{
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	queue<int> q;
	q.push(1);
	st[1] = true;
	while (q.size())
	{
		int t = q.front();
		q.pop();
		st[t] = false;
		for (int i = h[t]; i != -1; i = ne[i])
		{
			int j = e[i];
			if (dist[j] > dist[t] + w[i])
			{
				dist[j] = dist[t] + w[i];
				if (!st[j])
				{
					q.push(j);
					st[j] = true;
				}
			}
		}
	}
	if (dist[n] == 0x3f3f3f3f) return -1;
	return dist[n];
}
```
- 判断图中是否存在负环
  - 统计每条边的数量,如果cn[x] >= n
  - 说明路径中出现负环
  - 有可能出现的负环不是在1的路径中
  - 所以将所有点全部加进queue
```c++
for(int i = 1; i <= n; ++i)
{
  st[i] = true;
  q.push(i);
}
```
- 为什么根据边的数量为n+1推测出有两个相同的点?
- 因为spfa求得是最短路径,它只有存在负环,才能使相同的节点绕一圈,产生的路径更短

#### floyd算法
- `d[k,i,j]`
  - 从`i`点出发, 只经过`1-k`个点到达`j`
- 初始化d[N][N]
  - `i = j`初始化为0,其他的初始化成正无穷

```c++
void flord()
{
	for (int k = 1; k <= n; ++k)
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= n; ++j)
				d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```
---
#### 拓扑序列
- 对于一个有向图, 它的排序一定是由开头指向结尾的
	
		1 -> 2
		|	  /
		v  v
		3

		排序出来的为1 2 3
		1在2前面, 2在3前面, 1在3前面
- 判断所有入度为0的点, 并把所有入度为0的点入队
- 删除所有出边(将下个点的入度--)\
**时间复杂度O(n+m), n表示点数, m表示边数**
```c++
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```