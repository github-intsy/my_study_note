### 快速排序-分治思想
	快速排序是不稳定的
	可以变为pair的元素,让每个值都不同,这样就是稳定的了
#### 快排三步
1. 确定分界点: 可以是`q[l]`, `q[(l+r)/2]`,`q[r]`,`随机位置`等
2. 调整区间,`<=x`的在左边,`>=x`的在右边`(重要)`
```
这一步考察的是我们如何简洁而优美的调整数据
```
3. 递归处理左右两端数据
#### 暴力处理(忘记的情况下)
    开辟两个数组,将比x小的放进a,比x小的放进b
    然后再将a和b依次放入原数组
### 双指针法
1. 左边建立`i指针`,右边建立`j指针`
2. 先走`i`,遇到`<=x`的往后走,`>x`停下来,然后走`j`,直到`j`停下来
3. 交换`i`和`j`的数
4. 如此循环,直到`i`和`j`相遇为止
5. 结束循环就可以将整个区间一分为二递归处理

边界: 如果存在一个数或者没有元素就不用排序了

	每次判断的时候,都是先向中间移动一格,再进行判断,
	第一次判断时,先在两边外面,然后向中间移动一次,就能取到两边的数据
```c++
模板
void quick_sort(int q[], int l, int r)
{
	if (l >= r)
		return;
	int x = q[l], i = l - 1, j = r + 1;
	while (i < j)
	{
		while (q[++i] < x);
		while (q[--j] > x);
		if (i < j) swap(q[i], q[j]);
	}
	quick_sort(q, l, j);
	quick_sort(q, j + 1, r);
}
```
注意: 如果递归是传递`j`,则不能使用`x = q[r]`, 只能使用`q[(r + l)/2]` 或者 `q[l]`

反之,如果是`i`则不能使用`x = q[l]`,只能使用`q[(r+l + 1)/2]`或者`q[r]`

记忆一种即可,其他是对称的
|递归传递值|可以选择的key|不能选择的key|
|---|---|---|
|`j, j+1`|`q[(r+l)/2]` `q[l]`|`q[r]`|
|`i-1, i`|`q[(r+l+1)/2]` `q[r]`|`q[l]`|
---
#### 查找第k个数
```c++
int quick_sort(int* q, int l, int r, int k)
{
    if (l == r) return q[l];
    int x = q[l], i = l - 1, j = r + 1;
    while (i < j)
    {
        while (q[++i] < x);
        while (q[--j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    int xl = j - l + 1;
    if (k <= xl) return quick_sort(q, l, j, k);
    return quick_sort(q, j + 1, r, k - xl);
}
```