#### 概念
质数是指只能被1和自身整除的正整数。例如，2、3、5、7等都是质数，而4、6、8等则不是质数。
#### 试除法判断质数
1. 直接遍历, `O(N)`
2. 试除法, `O(√N)`
   1. 如果`d`能整除`n`, 那么显然`n/d`也能整除`n`
```c++
bool is_prime(int n)
{
    if (n < 2) return false;
    for (int i = 2; i < n/i; ++i)
        if (n % i == 0) return false;

    return true;
}
```
---
### 判断质因数
- 质因数就是指能够整除一个整数`n`, 并且自己本身是质数的数
- 比如, `12`的质因数就是`2 2 3`

```c++
void is_prime(int n)
{
    for (int i = 2; i <= n; ++i)
    {
        if (n % i == 0)
        {
            int s = 0;
            while (n % i == 0)
            {
                n /= i;
                ++s;
            }
            printf("%d %d\n", i, s);
        }
    }
    if (n > 1) printf("%d %d\n", n, 1);
}
```
---
#### 筛质数
- **质数定理 :**`1-n`中,有`n/ln n个质数`
- **时间复杂度 :** 粗略的是`O(n)`, 精细的为`O(nloglog n)`
##### 埃及筛法
```c++
void is_prime(int n)
{
    int cnt = 0;
    for (int i = 2; i <= n; ++i)
    {
        if (!st[i])//判断,如果是质数. 前几次一定是质数,可以初始化后面的数组
        {
            primer[cnt++] = i;//如果是质数就加到数组中去
            for (int j = i + i; j <= n; j += i) st[j] = true;//根据当前的质数筛除后面的所有当前倍数的数
        }
    }
    cout << cnt << endl;
}
```
##### 线性筛法
- 根据从小到大枚举的质数, 删除`质数*i倍的数`, 剩下的`2~n`内的数就全是质数
- n只会被最小质因子筛掉
```c++
void get_prime(int n)
{
    for (int i = 2; i <= n; ++i)
    {
        if (!st[i]) primer[cnt++] = i;//同上述埃及筛法
        for (int j = 0; primer[j] <= n / i; ++j)//枚举所有质数的i倍
        {
            st[primer[j] * i] = true;//把当前储存的质数的i倍删除
            if (i % primer[j] == 0) break; //当条件为true, 代表primer[j]一定是i的最小质因子
        }
    }
}
```
1. `i % pj == 0`, `pj`一定是`i`的最小质因子,`pj`也一定是`pj*i`的最小质因子
2. `i % pj != 0`, 说明`pj`一定`< i`的所有质因子, `pj`也一定是`pj*i`的最小质因子
3. 任何一个合数一定会被筛掉
4. 每一个数都只会有一个最小质因子, 所以每个数只会被筛一次, 所以它的时间复杂度是`线性的`

#### 理解
- 试除法为什么可以优化到`√n`
- 分解质因数虽然最坏`sqrt(n)`但是为什么一般情况下
- 朴素筛法为什么是`n ln n`的时间复杂度?
- 埃氏筛法是什么原理?
- 线性筛法为什么是线性的?