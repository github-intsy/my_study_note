- 高斯消元可以在`n^3`的时间内求出含有**多个**未知数的多元方程或者一元方程组
- 高斯消元的解存在3个
  - 无解
  - 无穷多组解
  - 唯一解
##### 初等行列变换
1. 把某一行乘以一个非零的数
2. 交换某两行
3. 把某行的若干倍加到另一行上去
```
a11X1 + a12X2 + ... + a1nXn = b1
        a22X2 + ... + a2nXn = b2
                .
                .     
                         Xn = bn
可以逆推出上一层的所有未知数
```
1. 完美阶梯型
   1. 唯一解
2. 推导出0=非零
   1. 无解
3. 推导出几个方程结果相同, 多余出来了
   1. 无穷多组解

### 高斯消元
枚举每一列
1. 找到绝对值最大的一行
2. 将该行换到最上面去
3. 将该行的第一个数变为`1`,`等式两边除以n得到第一个数字为1`
4. 把下面所有行的当前列消成`0`,`第一行和下面所有行挨个相加减`\
   **循环**\
   处理好的最上面的行不再处理\
   找到当前列绝对值最大的那一行,移动到固定的行下面\
   并将下面的方程的前`n-1`个数变为0

```c++
int gauss()
{
	int c, r;
	for (c = 0, r = 0; c < n; c++)
	{
		int t = r;//默认0为最上方
		for(int i = r; i < n; ++i)
			if(fabs(a[i][c]) > fabs(a[t][c]))
				t = i;//判断当前列的最大值,置为最上方
	
		if (fabs(a[t][c]) < eps) continue;

		for (int i = c; i <= n; ++i) swap(a[t][i], a[r][i]);//交换位置
		for (int i = n; i >= c; --i) a[r][i] /= a[r][c];//该行的第c个位置变为1
		for (int i = r + 1; i < n; ++i)//使用消元法将r行c列下面的所有c列元素变为0
			if (fabs(a[i][c]) > eps)
				for (int j = n; j >= c; --j)
					a[i][j] -= a[r][j] * a[i][c];//r行c列为1, r+1行整体方程 - r行方程 * r+1行c列方程的倍数

		++r;
	}

	if (r < n)
	{
		for (int i = r; i < n; ++i)
			if (fabs(a[i][n]) > eps)
				return 2;//无解
		return 1;//有无穷多组解
	}

	for (int i = n - 1; i >= 0; --i)
	{
		for (int j = i + 1; j < n; ++j)
		{
			a[i][n] -= a[i][j] * a[j][n];//处理未知数
		}
	}
	return 0;//唯一解
}
```