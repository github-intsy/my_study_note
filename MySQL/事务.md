<details><summary>目录</summary>

- [什么是事务？](#什么是事务)
- [为什么会出现事务？](#为什么会出现事务)
- [了解事务引擎](#了解事务引擎)
- [事务基本操作](#事务基本操作)
- [事务异常](#事务异常)
  - [自动提交](#自动提交)
- [事务隔离](#事务隔离)
  - [隔离级别](#隔离级别)
  - [查看隔离级别](#查看隔离级别)
- [读-写](#读-写)


</details>

## 什么是事务？
事务就是为了完成实际事件中由**一条或多条**sql语句构成的集合体。这一组sql语句要么全部成功，要么全部失败。

## 为什么会出现事务？
>事务被 MySQL 编写者设计出来,本质是为了当应用程序访问数据库的时候,事务能够简化我们的编程模型,不需要我们去考虑各种各样的潜在错误和并发问题.可以想一下当我们使用事务时,要么提交,要么回滚,我们不会去考虑网络异常了,服务器宕机了,同时更改一个数据怎么办对吧?因此事务本质上是为了应用层服务的.而不是伴随着数据库系统天生就有的.

## 了解事务引擎
```sql
show engines;
-- 查看各引擎是否支持事务

show variables like 'autocommit';
-- 查看事务自动提交
set autocommit=0;   --设置事务自动提交关闭
set autocommit=1;   --设置事务自动提交打开

show processlist;   --查看有多少用户访问当前数据库
```
> - DEFAULT默认支持事务
> - Innodb支持事务
> - Myism不支持

## 事务基本操作
```sql
start transaction; --开始一个事务
begin              --开始一个事务

savepoint save1;    --创建一个保存点save1

rollback to save1;  --回滚到保存点save1
rollback;           --回滚到事务刚开始

commit;             --结束一个事务
-- 如果事务提交后，无法回滚
```
## 事务异常
>事务执行过程中系统异常断开，事务执行就会自动回滚。\
使用commit提交事务后，即使异常情况断开连接，也不会回滚。`保证原子性`

### 自动提交
>mysql默认单sql语句是一个事务

如果打开自动提交，就是默认执行commit提交记录。\
当系统崩溃时，自动执行commit提交记录

如果关闭自动提交，当系统崩溃时，由于没有自动提交，不会执行commit，自动回滚到事务开始。

## 事务隔离
> - 在事务场景中，隔离是必要的。
> - 运行中的事务，进行互相隔离
> - 根据影响的程度不同，设置不同的隔离级别。

事物之间应该按照到来时间顺序隔离起来，事务a执行的所有结果不能影响到事务b。
### 隔离级别
- 读未提交
  - 两个事务同时启动，这端未提交，另外一端就已经看到
- 读提交
  - 提交之后才能看到
- 可重复读
  - 事务ab同时运行：事务a的修改，事务b看不见。\
    只有事务a commit提交，事务b结束，事务b新起事务才能看见
  - 默认的隔离级别
- 串行化 
  - 对事务强行进行排序，串行访问事务
  - 事务的最高隔离级别

### 查看隔离级别
```sql
select @@global.tx_isolation;
--global是session的默认配置，每次登陆会话，session读取global的配置
--查看全局隔离级别

select @@session.tx_isolation;
--查看当前会话全局隔离级别

select @@tx_isolation;
--与第二个相同，简写
```
>mysql采取就近原则，默认使用session的隔离级别

> 脏读现象：两个事务运行中，一个事务未运行完，另一个事务就能将数据读到。

|隔离级别|效果|
|---|---|
|读未提交<br>（不推荐）|两个并行事务，a修改数据而且没有commit，b马上能看到。|
|读提交<br>（不推荐）|两事物并行期间，a只能看到自己需改的数据，b看不到。<br>a `commit`之后，b未结束，也能看到a修改的数据<br>a事务commit后，b立马看到；b事务前一秒和后一秒看到的数据不相同，这种现象叫做`不可重复读`<br>事务在执行过程中需要保持原子性，其他事物操作不应该干扰它|
|可重复读（默认隔离级别）|两事物并行期间，事务a的所有修改操作，事务b看不到。**事务a结束，事务b也看不到**。只有事务a，b都结束了，事务b才能看到a的修改内容|
|串行化|`对所有操作进行加锁，进行串行化，不会有问题，但是只要串行化，效率很低，几乎不会被采用`<br>两个事务并行，其中一个事务做修改，做修改操作的事务就会被阻塞。直到另外的事务结束。<br>两个事务同时修改，阻塞先修改的，后修改的不阻塞，后修改的结束了，先修改的才能继续操作。|

## 读-写
多版本并发控制（MVCC）是一种用来解决`读写冲突`的**无锁并发控制**
1. 每个事物都要有自己的事务ID，可以根据事务ID的大小，来决定事物到来的先后顺序
2. mysqld可能会面临同时处理多个事务的情况。事务也有自己的生命周期。mysqld要对多个事务进行管理。事务在我看来，mysqld中一定是对应的一个或者一套结构体对象

每次修改数据**之前**，都会将被修改的数据在`undo log`的文件中保存一个历史版本\
`undo log`是运行期间申请的一个空间，数据不操作了`undo log`就会被清理掉

事务隔离的本质：\
当前读：读取最新的记录，就是当前读。\
快照读：读取历史版本，就叫做快照读。\
如果多个事务同时删改查的时候，都是当前读，是要加锁的。如果同时select过来，也要读取最新版，就需要加锁，这就是串行化。\
如果是快照读，读取历史版本，是不受加锁限制的。也就可以并行执行。这样就提高了效率

`详细查看课件`