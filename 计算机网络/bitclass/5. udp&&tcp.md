<details><summary>目录</summary>

- [端口](#端口)
- [TCP协议](#tcp协议)
  - [tcp可靠性](#tcp可靠性)
  - [3次握手4次挥手](#3次握手4次挥手)
    - [为什么只能是3次握手？](#为什么只能是3次握手)
    - [四次挥手](#四次挥手)
      - [如何保证server断开client链接后，能够使用相同的端口？](#如何保证server断开client链接后能够使用相同的端口)
  - [流量控制](#流量控制)
  - [滑动窗口](#滑动窗口)


</details>

## 端口
端口号位于`传输层`\
我们使用的网路IO接口, 其实并不直接是发送和接收接口, 而是拷贝接口

>send发送数据和recv接收数据, 不是将数据直接发送到网络中, 而是将数据拷贝到OS的发送/接受缓冲区中, 应用层就返回了

>发送方和接收方都存在发送和接收缓冲区, 发送方也可以接收, 所以通信是全双工的

tcp叫做**传输控制协议**\
控制数据什么时候发送, 发送多少的问题

## TCP协议
>1. tcp协议室友标准长度的：20，先读20字节的内容
>2. 转换成一个结构化的数据，立马提取标准报头中的4位首部长度，表示的是tcp报头的总长度\
    4位首部长度*4字节，表示报头长度为[0-60]，又因为报头的最小长度是20，所以应该是[20-60]\
    - tcp协议是一个带有自描述字段的变长的包头
>3. 就能得到后续报头的剩余大小, $X*4-20=0$, 表示标准报头, 后面内容是有效载荷部分, 如果结果不是0, 则继续读取剩余报头内容
>4. 只要把tcp报头处理读取完毕, 剩下的就是有效载荷部分

报头中包含的目的端口号, 就可以找到应用层进程, 数据就能交付给进程

**我们收到一个报文，是如何找到曾经bind特定port的进程的！网络协议栈和文件是什么关系**\
系统将`{port， PCB}`的映射关系在bind端口号的时候添加进OS维护的hash中。\
接收数据的时候，根据报文中包含的目的port在hash中找到对应进程的PCB

-  文件存在自己的读写缓冲区

进程PCB中存在其维护的文件描述符表`files_struct`，文件描述表中存在sock，在linux中一切皆文件，sock也是文件，传输层将数据放在sock的读写缓冲区中。\
从而完成网络通信

### tcp可靠性
如果通信距离变成，可靠性就无法保证

一个报文只有收到了应答，才能保证该报文的可靠性。

>1. 我们认为，只有收到了应答，历史消息我才能100%确认对方收到--确认应答了才算可靠
>2. 双方通信, 一定存在最新的数据, 没有应答! -- 最新消息一般无法保证可靠性

tcp双方的通信地位是对等的，只需要搞定一个朝向的通信过程

确认应答和确认序号：接收方已经接收到了ACK序号之前的所有的（连续）报文\
如果发送序号是10，11，13，则只能返回12
>- 16位窗口大小， 做流量控制\
将自己的缓冲区大小传递在窗口大小

    服务器未来会遇到各种客服端请求，由于内容不同，所以tcp报文也是有类型的

>1. 发送端如何判断丢包?\
定的超时策略,超时了,就判定丢包
>2. 思考点:发送端,发出去数据,被发出的数据,并不是马上移除,而是能保持一段时间
>3. 超时时间怎么定?`一定不是固定的`\
网络中的传输速度是不固定的, 所以时间也不能固定

<!-- 掌握tcp报头中6个标志位和32位序号和32位确认序号-->

连接结构体是tcp保证可靠性的数据基础\
3次握手是创建链接结构体的基础。\
tcp3次握手就间接保证链接可靠性

### 3次握手4次挥手
>1. 三次握手不一定非得成功，最担心的其实是最后一个ACK丢失，但是有配套的解决办法
>2. 链接是需要被管理起来的，被OS管理起来的，先描述再组织。维护一个链接是有成本的

#### 为什么只能是3次握手？
1. 一次握手？绝对不行，server一定要维护建立好的连接，client如果持续向server发送请求，server会创建大量的连接，这样就造成server端的硬件资源减少，`SYN洪水`
2. 两次握手？同上
3. 三次握手为什么可以？
   1. 是用最小成本验证全双工通信信道是通畅的
   2. 最后一次推送是client推送ack，一定是client先建立连接，也就是说如果client想要让server建立连接，一定是自己先建立连接
   3. 三次握手可以有效防止单机对服务器进行攻击
4. 偶数握手存在漏洞，三次以上就是在浪费资源，因为三次握手已经能验证全双工了

#### 四次挥手
断开连接是双方的事情，需要征得双方同意

断开连接，不发送数据，指的是不发送用户数据。不代表底层没有管理报文的交互。

如果server出现大量的close_wait状态
1. 服务器有bug，没有做close文件描述符的动作
2. 服务器有压力，可能一直在推送消息给client，导致来不及接受close
3. 保证最后一个ACK尽可能的被对方收到
4. 双方断开连接的时候，网络中还有滞留的报文，所以需要等待2*MSL时间，保证滞留报文进行消散
   1. MSL：数据在网络中的存活时间，也就是数据从发送到接收方的时间
   2. 服务器断开连接，导致服务器处于time_wait状态，此时服务器会维持该状态一段时间，该链接和端口都会被占用

##### 如何保证server断开client链接后，能够使用相同的端口？
```c++
int opt = 1;
setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
//设置套接字复用
```
使用setsockopt()shezhi socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符

### 流量控制
1. 发送方怎么在第一次就知道对方的接受能力？在通信之前，早就做过三次握手，交换窗口大小。
2. 如果我们发送数据，没有收到数据前， 我们必须将自己的已经发送的数据暂时保存起来，为了支持重传（保存在发送缓冲区）

### 滑动窗口
```c++
win_start = 0;
win_end = win_start + tcp_win
//未来无论如何滑动，都要保证对方都能接受
//滑动窗口大小=对方通告给我的自己的接受能力大小
```
1. 滑动窗口可能向右滑动，也可能保持不变
2. 滑动窗口的大小根据接收方的接收缓冲区的大小变化，如果接收缓冲区满，则滑动窗口变为0
3. 如果连续收到3个1000，则会触发重传机制\
   1. 确认序号的定义：ACK seq X + 1，表示X+1之前的所有数据全部都收到了
4. 滑动窗口其实是一个环形队列的数据结构

`滑动窗口大小=min(拥塞窗口，窗口大小(我自己的接受能力))`