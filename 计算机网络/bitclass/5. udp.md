
## 端口
端口号位于`传输层`\
我们使用的网路IO接口, 其实并不直接是发送和接收接口, 而是拷贝接口

>send发送数据和recv接收数据, 不是将数据直接发送到网络中, 而是将数据拷贝到OS的发送/接受缓冲区中, 应用层就返回了

>发送方和接收方都存在发送和接收缓冲区, 发送方也可以接收, 所以通信是全双工的

tcp叫做**传输控制协议**\
控制数据什么时候发送, 发送多少的问题

## TCP协议
>1. tcp协议室友标准长度的：20，先读20字节的内容
>2. 转换成一个结构化的数据，立马提取标准报头中的4位首部长度，表示的是tcp报头的总长度\
    4位首部长度*4字节，表示报头长度为[0-60]，又因为报头的最小长度是20，所以应该是[20-60]\
    - tcp协议是一个带有自描述字段的变长的包头
>3. 就能得到后续报头的剩余大小, $X*4-20=0$, 表示标准报头, 后面内容是有效载荷部分, 如果结果不是0, 则继续读取剩余报头内容
>4. 只要把tcp报头处理读取完毕, 剩下的就是有效载荷部分

报头中包含的目的端口号, 就可以找到应用层进程, 数据就能交付给进程

**我们收到一个报文，是如何找到曾经bind特定port的进程的！网络协议栈和文件是什么关系**\
系统将`{port， PCB}`的映射关系在bind端口号的时候添加进OS维护的hash中。\
接收数据的时候，根据报文中包含的目的port在hash中找到对应进程的PCB

-  文件存在自己的读写缓冲区

进程PCB中存在其维护的文件描述符表`files_struct`，文件描述表中存在sock，在linux中一切皆文件，sock也是文件，传输层将数据放在sock的读写缓冲区中。\
从而完成网络通信

### tcp可靠性
如果通信距离变成，可靠性就无法保证

一个报文只有收到了应答，才能保证该报文的可靠性。

>1. 我们认为，只有收到了应答，历史消息我才能100%确认对方收到--确认应答了才算可靠
>2. 双方通信, 一定存在最新的数据, 没有应答! -- 最新消息一般无法保证可靠性