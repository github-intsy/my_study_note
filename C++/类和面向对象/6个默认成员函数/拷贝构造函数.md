拷贝构造函数也是特殊的成员函数，其特征如下
1. 拷贝构造函数是构造函数的一个重载形式
2. 拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用

拷贝函数是我们需要复制已有对象数据的时候所创建的一个默认成员函数

对象初始化时自动调用构造函数
调用的是拷贝构造
但是调用参数时要先传参数
传参的过程又是一个拷贝构造的调用
```c++
class Date
{
public:
    Date(Date d)
    {
        _year = d._year;
        _month = d._month;
        _day = d._day;
    }
private:
    int _year;
    int _month;
    int _day;
};

Date d2(d1);

函数调用的时候传参,创建一个Date类,此时,d1自己调用自己无限递归,系统死循环
具体过程:Date d2(d1) -> Date d(d1) -> Date d(d1) ... ...
解决办法：将传值改为传引用
Date(Date& d)
{
    _year = d._year;
    _month = d._month;
    _day = d._day;
}
```
调用别名不会创建额外空间,复制一次数据后就会返回
```C++
Date(const Date& d)
{
    _year = d._year;
    _month = d._month;
    _day = d._day;
}
//最终版本,最优代码

Date d1(2023,4,11);
d1.Print();

Date d2(2023,4,15);
d2.Print();
```
`d1 = d2;  `      两个对象已经存在且初始化好了,现在我想把d2赋值(拷贝)给d1,复制
`Date d3(d1);`    d3还不存在,构造d3时用d1去初始化

`Date d4 = d1;`   特别注意:
这里是拷贝构造,不是operator=

如果我们不实现拷贝构造和operator=,编译器会自动生成默认的拷贝构造和operator=,默认的会完成按照字节的值拷贝.
也就是说,有些类,我们是不需要去实现拷贝构造和operator=的
operator==就不是默认成员函数

#### 浅拷贝问题:
    将对象按一个一个字节拷贝过去
    如果我们没有定义拷贝构造函数,编译器会生成默认拷贝构造函数,这个默认拷贝构造函数是浅拷贝
    浅拷贝是值拷贝,会导致创建的两个不同的对象中的指针,指向同一块开辟的空间.
    而创建的对象在生命周期结束后,会自动调用默认的析构函数,由于两个指针指向同一块空间,会导致对同一块空间释放两次,造成系统崩溃
    对于时间类的使用,仅仅靠默认拷贝构造函数就足够了.对于复杂的类,浅拷贝就不够用了