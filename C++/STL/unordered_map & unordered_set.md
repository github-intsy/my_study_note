### map/set 和 unordered map/unordered_set 有什么区别和联系?
1. 他都可以可以实现key和key/value的搜索场景，并且功能和使用基本一样。
2. map/set的底层是使用红黑树实现的，遍历出来是有序的，增删查改的时间复杂度是0(logN)
3. unordered map/unordered set的底层是使用哈希表实现的，遍历出来是无序的，增删查改的时间复杂度是0(1)
4. map/set是双向迭代器 unordered_map和unorder_set是单向迭代器
    
    搜案树还取决于树的高度，也就是说数据量越大效率会逐步降低。而哈希通过映射关系直接进行查找，效率非常高，那么哈希最大的问题就是如何解决哈希冲突
    
        我们会发现: 插入和查找31效率都很低，
        所以可以分析出结论，影响哈希表效率的是哈希冲突哈希冲突越多，效率越低。

    哈希冲突: 不同的值映射到了相同的位置


    闭散列:也叫开放定址法，当发生哈希冲突时，如里哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的"下一个”空位置中去。

    下一个空位置可以是下一个,也可以是下一个的2次方
#### 开放定制法:
1. 线性探测，依次往后去找一个空位置:
2. 二次探测，按2次方往后找空位置
    
        二次探测让冲突的一片数据相对更分散了，不会聚集到一起，形成连片冲突
        
        我们可以看到闭散列-开放定制法不是一种好的解决方式，
        因为他是一种我的位置被占了，我就去抢别人的位置思路
        也就是说他的哈希冲突的会互相影响，我冲突占你的，你冲突了占他的，他冲突了....，
        没完没了，整体效率都遍低

#### 字符串算法
    由于取模操作的对象是整形, 当为字符串的时候就需要我们将其转化成整形后运算. 

    运算思路: 遍历字符串. 将所有ascii码值相加

    出现问题: 顺序不同,值相同

    解决: 每一位值运算前都乘以131
    取自: BKDR Hash
#### 如果想要保持插入顺序
    在节点上多建立两个指针,next和prev.
    最后输出的时候遍历next就行
    删除需要用prev连接前后链表
    
#### 极端条件
如果绝大部分数据储存在一个位置上, 这个时候哈希桶效率就会下降, 如何解决?
    
    在一个位置挂的桶数为8后,就挂成红黑树