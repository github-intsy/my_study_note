cpp中的引用可以和C中的指针达到相同的效果
1.引用在定义时初始化
2.一个变量可以有多个引用
3.引用一旦引用一个实体,就不能再引用其它实体,而指针可以在任何时候指向任何一个同类型实体
4.没有NULL引用,但有NULL指针
5.在sizeof中含义不同:引用结果为引用类型的大小,但指针始终是地址空间所占字节个数(32位平台下占4个字节)
6.引用自加即引用的实体增加1,指针自加即指针向后偏移一个类型的大小
7.有多级指针,但没有多级引用
8.访问实体方式不同,指针需要显式解引用,引用编译器自己处理
9.引用比指针使用起来相对更安全

引用不是重新定义一个变量,而是给已经存在变量取了一个别名,编译器不会为引用变量开辟一个空间,它和它引用的变量共用一块内存空间
例如:
```c++
    void TestRef()
    {
        int a = 1;
        //int& c = a;
        int d = 2;
        c = d;      //分析:这里是变成了d的引用?
                                no
                    //还是将d赋值给c?
                            yes
        return 0;
    }


int main()
{
    const int a = 0;
    //int& b = a;
    //b的类型int,编译不通过,原因:a是只读
    ,b的类型是int,也就是可读可写的
    const int& b = a;

    int c = 1;
    int& b = c;
    const int& e = c; //行不行?
    //总结:引用区别名时,变量访问的权限可以缩小,
    不能放大
    return 0;
}

```
```c++
int i = 0;
double db = i;//隐士类型转换
const double& rd = i;
const float rf = i;
```
隐士类型转换:隐士类型转换由编译器自动执行,不需要程序员干涉,隐士类型转换通常有两种情况
1. 赋值转换:将一种类型的数据赋值给另外一种类型的变量时，发生隐式类型转换
eg: 在对变量赋值时，若等号两边的数据类型不同，需要把右边表达式的类型转换为左边变量的类型，这可能会导致数据失真（精度降低），所以隐式类型转换不一定是安全的

2. 运算转换：C语言中不同类型的数据需要转换成同一类型，才可以进行计算。. 字符型、整型、浮点型之间的变量通过隐式类型转换，可以进行混合运算（不是所有数据类型之间都可以隐式转换）
    转换规则如下： 转换按数据长度增加的方向进行，以保证数据精度不降低。

发生隐士类型转换时会创建一个被赋值的临时变量
eg:double db = i;这时创建一个double的临时变量
创建的临时变量具有常性

变量之间赋值没有权限的缩小和放大的关系,引用才有

权限的放大
```c++
    const不能给非const,const只能给const
    const int a = 10;
    //int& b = a;
    const int& b = a;
```
权限的缩小
```c++
    非const即可给非const也可给const
    int c = 20;
    int& d = c;
    const int& e = c;

    return 0;
```
不同类型之间的赋值,运算操作会创建一个临时变量,这个临时变量具有常性.
常性指的是该内存空间里面的数据只能是可读的,不能是可读可写的


函数的返回类型可以是引用类型
返回值是引用类型的话会导致数据不是安全的
代码:
```c++
    int& Add(int a, int b)
    {
        int c = a + b;
        return c;
    }
    int main()
    {
        int& ret = Add(1, 2);
        Add(3, 4);
        cout << ret << endl;
        return 0;
    }
```
第一个Add函数执行完成后会释放掉c的空间,但是第二次调用Add函数时会重新调用c的空间,此时调用的c的地址和第一个调用c的地址相同,而ret是c的别名,c中数据的改变会影响ret数据的改变,因此不安全.
看编译器,有些编译器在栈帧销毁后会对原来空间的数据进行一个重置,而有些编译器不会

改进:
```c++
    int& Add(int a, int b)
    {
        static int c = a + b;
        return c;
    }
    int main()
    {
        int& ret = Add(1, 2);
        Add(3, 4);
        cout << ret << endl;
        return 0;
    }
```
static修饰的int会改变他的生命周期,第二次调用函数的时候不会运行static int c = a + b;
是因为这个时候c已经创建过了

一个函数要使用引用返回,返回变量出了这个函数的作用域还存在,就可以使用引用返回,否则就不安全

那么函数使用引用返回好处是什么?
少创建拷贝一个临时对象,提高效率
```c++
    Swap(int& r1, int& r2)      ->传参的过程相当于
    {                           int& r1 = a;
        int tmp = r1;
        r1 = r2;
        r2 = tmp;
    }

    int main()
    {
        int a = 1;
        int b = 2;
        Swap(a,b);  ->利用引用时不需要传递地址
    }
```