### 单例模式
**一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享**。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理。
```c++
class Singleton
{
public:
    static Singleton* GetInstance()
    {
        //双检查
        if(_pinst == nullptr)
        {
            unique_lock<mutex> lock(_mtx);
            if(_pinst == nullptr)
            {
                _pinst = new Singleton;
            }
        }
        
        return _pinst;
    }
    Singleton(const Singleton& s) = delete;
private:
    static Singleton* _pinst;
    static mutex _mtx;
};

Singleton* Singleton::_pinst = nullptr;
Singleton*
为什么成员变量需要静态的?
因为静态成员函数里面只能调用静态的成员对象
前面只是声明,还需要在类外面进行定义
```
- 加锁是为了防止两个线程同时通过if循环导致创建了两个对象
- 加上双判断是因为只有第一次需要加锁
  - 因为只要第一次创建对象,_pinst不为空,这样后面都不能通过if判断,保证了线程的安全
  - 多次加锁会浪费额外的性能
- 第一个防止对象已经创建好后,还需要每次加锁
- 第二个防止重复创建对象

#### 特殊处理
1. 如果要手动释放单例对象,可以调用DelInsrance
   1. DelInsrance用于释放对象
2. 如果需要程序结束时,正常释放单例对象,可以加入以下设计
```c++
class GC
{
public:
    ~GC()
    {
        Singleton::DelInstance();
    }
};
static GC gc;
```
#### 饿汉模式和懒汉模式
- 懒汉模式
  - 第一次获取对象时,再创建对象
- 饿汗模式
  - 一开始就创建对象
  - 指的是main函数之前就创建对象

```c++
//饿汗模式,一开始(main函数之前)就创建对象
class Singleton
{
public:
    static Singleton* GetInstance()
    {
        return &_inst;
    }
    Singleton(const Singleton& e) = delete;
private:
    Singleton()
    {}
    
    static Singleton _inst;
};

Singleton Singleton::_inst;
//static对象是在main函数之前创建的,这会只有主线程,所以不存在线程安全问题
```
#### 懒汉模式和饿汉模式的区别
1. 懒汉模式需要考虑线程安全和释放的问题，实现相对更复杂，饿汉模式不存在以上问题，实现简单
2. 懒汉是一种懒加载模式需要时在初始化创建对象，不会影响程序的启动。饿汉模式则相反，程序启动阶段就创建初始化实例对象，会导致程序启动慢，影响体验。
3. 如果有多个单例类，假设有依赖关系(B依赖A)，就不能饿汉，因为无法保证创建初始化顺序. 如果用懒汉就可以手动控制
   1. 饿汉模式中的成员都是静态的,对于静态对象,我们无法保证谁先创建

**总结** : 实际中懒汉模式还是更实用一些

---
### 类型转换
