### 多态的概念:
    通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。
#### 多态的条件
    满足多态的条件: 跟对象有关，指向哪个对象就调用他的虚函数
    不满足多态的条件: 对类型有关，调用的类型是谁，调用就是谁的

1. 虚函数的重写
2. 父类对象的指针或者引用去调用虚函数

### 基类和派生类之间的关系
    可以
    1. 子类对象可以赋值给父类对象/指针/引用
    2. 基类的指针可以通过强制类型转换赋值给派生类的指针
   
    不可以
    1. 基类对象不能赋值给派生类对象

### 虚函数
    被virtual修饰的类成员函数就是虚函数
```c++
class Person {
public:
    virtual void BuyTicket() { cout << "买票-全价" << endl;}
};
```
### 虚函数的重写(覆盖)
    派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类
    型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。
1. 是由virtual修饰的函数
2. virtual修饰的函数如果想要表现出多态，就必须在父类中也实现一个虚函数
3. 如果父类有一个virtual修饰的虚函数,那么父类就会产生一个指向虚表的虚指针,并且虚函数的地址会储存在虚表中.如果有一个子类继承了父类,那么不管子类有没有重写这个虚函数,都会得到父类的虚指针和虚表,此时可以认为父类和子类公用一个虚指针,指向同一个虚表(父类和子类的同一个虚表),大小为4(详情查看代码***)
4. 去重写的时候,如果父类有虚表了,子类就不需要了
```c++
class Person{
public:
    virtual void BuyTicket()
    {
        cout << "Person::买票-全价" << endl;
    }
};
//注意：在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，
//虽然也可以构成重写(因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性),
//但是该种写法不是很规范，不建议这样使用
class Student : public Person
{
public:
    virtual void BuyTicket()
    {
        cout << "Student::买票-半价" << endl;
    }
};

void func(Person& p)
{
    p.BuyTicket();
}

int main()
{
    Person ps;
    Student st;

    Func(ps);
    Func(st);
    return 0;
}
```
```c++
int main()
{
    Person* p1 = new Person;
    delete p1;

    Person* p2 = new Student;
    delete p2;                  
}
out:~Person()
    ~Person()

如果student析构函数中有资源释放
这里没有调用到student的析构函数,就会发生内存泄漏
问:析构函数是否需要定义成虚函数?
答:需要,因为如果不定义成虚函数,用基类指针去释放派生类对象,会发生释放不完全的情况,有可能发生内存泄漏的风险

不构成多态:
调用的指针是谁就调用谁的析构函数
```
```c++
***
class Person {
public:
    virtual void func()
    {
        cout << "Person::func()" << endl;
    }
};
class Student : public Person
{
public:
    virtual void func()
    {
        cout << "Student::func()" << endl;
    }
};
int main()
{
    cout << sizeof(Student) << endl;
    return 0;
}
输出结果为4
```
#### 1. 虚函数重写的例外(了解)
    协变(基类与派生类虚函数返回值类型不同)

    派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引
    用，派生类虚函数返回派生类对象的指针或者引用时，称为协变。(了解)
```c++
class A{};
class B : public A {};

class Person {
public:
    virtual A* f() {return new A;}
};

class Student : public Person {
public:
    virtual B* f() {return new B;}
};
返回的派生类和基类都不一定是自己的派生类和基类
```
#### 2. 析构函数的重写(基类与派生类析构函数的名字不同)
    如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual关键字，都与基类的析构函数构成重写，
    虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，
    编译后析构函数的名称统一处理成destructor。

    只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函数，才能构成多态，才能保证p1和p2指向的对象正确的调用析构函数
### C++11 override 和 final
#### 1. final：修饰虚函数，表示该虚函数不能再被重写
    final表示最终的,所以final修饰的虚函数不能被重写
    额外的: final用来修饰类,表示该类为最终类, 也不能被重写
#### 2. override: 检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。
    注意override是向上兼容的,检查的是派生类的虚函数是否重写,
### 重载、覆盖(重写)、隐藏(重定义)的对比
- 重载
  - 两个函数在同一作用域
  - 函数名相同, 参数不同
- 重写(覆盖)
  - 两个函数分别在基类和派生类的作用域
  - 函数名/参数/返回值必须相同(协变例外)
  - 两个函数必须是虚函数
- 重定义(隐藏)
  - 两个函数分别写在基类和派生类的作用域
  - 函数名相同
  - 两个基类和派生类的同名函数不构成重写就是构成重定义
### 抽象类
    在虚函数的后面加个= 0, 则这个函数为纯虚函数.包含纯虚函数的类叫做抽象类（也叫接口类）
    抽象类不能实例化出对象。
    派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。
    纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。
#### 接口继承和实现继承
    普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。
    虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，
    继承的是接口。所以如果不实现多态，不要把函数定义成虚函数。
```c++
class Person
{
public:
    virual void func() = 0;
    //纯虚函数可以定义,也可以只声明,但是定不定义都不影响后面的派生类
    //即使定义了纯虚数,也不会被使用
};
class Student
{
public:
    virtual void func()
    {
        cout << "func()" << endl;
    }
};
纯虚函数的作用:
1. 强制子类去完成重写
2. 表示抽象的类型. 抽象就是实际中没有对应的实体的
```
### 多态的原理
#### 虚函数表
```c++
// 这里常考一道笔试题：sizeof(Base)是多少？
class Base
{
public:
    virtual void Func1()
    {
        cout << "Func1()" << endl;
    }
private:
    int _b = 1;
};
在32位平台下是8
在64位平台下是16
存在内存对齐
```
    通过观察测试我们发现b对象是8bytes，除了_b成员，还多一个__vfptr放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关)，
    对象中的这个指针我们叫做虚函数表指针(v代表virtual，f代表function)。
    一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，
    虚函数表也简称虚表。那么派生类中这个表放了些什么呢？
```c++
// 针对上面的代码我们做出以下改造
// 1.我们增加一个派生类Derive去继承Base
// 2.Derive中重写Func1
// 3.Base再增加一个虚函数Func2和一个普通函数Func3
class Base
{
public:
    virtual void Func1()
    {
    cout << "Base::Func1()" << endl;
    }
    virtual void Func2()
    {
        cout << "Base::Func2()" << endl;
    }
    void Func3()
    {
    cout << "Base::Func3()" << endl;
    }
private:
    int _b = 1;
};
class Derive : public Base
{
public:
    virtual void Func1()
    {
    cout << "Derive::Func1()" << endl;
    }
private:
    int _d = 2;
};
int main()
{
    Base b;
    Derive d;
    return 0;
}
1. 只要是继承虚函数,都会把虚函数本身的地址继承给派生类
2. 如果没有重写虚函数,那么在虚表中的虚指针会指向同一个储存在代码段里的虚函数
3. 如果发生了重写, 那么在派生类的虚表里,会把派生类继承下来的虚表中虚函数的地址进行覆盖
4. 虚函数和虚表都是储存在代码段里的
5. 虚表的本质就是一个函数指针数组
6. virtual修饰的函数本质是有一个数组指针指向函数数组指针
vftptr虚表地址: 00E4DA58
栈变量: 008FFCBC
堆变量: 009AC878
代码段常量: 00E4DAB8
虚函数地址: 00E414CE
普通函数地址: 00E41122
//可以发现,虚表,代码段常量,虚函数,普通函数的地址都是E4开头的
//所以可以得出,他们都是储存在代码段中的
```
1. 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就
是存在部分的另一部分是自己的成员。
2. 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重
写的Derive::Func1，所以虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖。重写是语法的
叫法，覆盖是原理层的叫法。
3. 另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会
放进虚表。
4. 虚函数表本质是一个存虚函数指针的指针数组，一般情况这个数组最后面放了一个nullptr。
5. 总结一下派生类的虚表生成：a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基
类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在
派生类中的声明次序增加到派生类虚表的最后。
6. 这里还有一个童鞋们很容易混淆的问题：虚函数存在哪的？虚表存在哪的？ 答：虚函数存在虚表，虚表
存在对象中。注意上面的回答的错的。但是很多童鞋都是这样深以为然的。注意虚表存的是虚函数指
针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中。另外
对象中存的不是虚表，存的是虚表指针。那么虚表存在哪的呢？实际我们去验证一下会发现vs下是存在
代码段的，Linux g++下大家自己去验证？
#### 动态绑定与静态绑定
    1. 静态绑定又称为前期绑定(早绑定)，在程序编译期间确定了程序的行为，也称为静态多态，比如：函数重载
    2. 动态绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态。
    3. 本小节之前(5.2小节)买票的汇编代码很好的解释了什么是静态(编译器)绑定和动态(运行时)绑定。
```c++
int i = 0;
double d = 1.1;
//静态绑定 静态的多态
f1(i);
f1(d);

//动态绑定 动态的多态(动态: 运行时到虚表中找虚函数地址)
Base* p = new Base;
p->Func1();
p = new Derive;
p->Func1();
```
#### 监视窗口
    在有些情况下,vs的监视窗口会隐藏隐函数的信息,这是它觉得没有必要展示的内容
```c++
class Base
{
public:
    virtual void func1()
    {
        cout << "Base::func1()" << endl;
    }
    virtual void func2()
    {
        cout << "Base::func2()" << endl;
    }
private:
    int a;
}
class Derive : public Base
{
public:
    virtual void func1()
    {
        cout << "Derive::func1()" << endl;
    }
    virtual void func3()
    {
        cout << "Derive::func3()" << endl;
    }
    virtual void func4()
    {
        cout << "Dervie::fun4()" << endl;
    }
}
监视窗口:
只显示了数组的前两个元素,看不到子类继承父类中虚表中,后来加上去的func3和func4
监视窗口有时候是不对的，因为他觉得fun3和fun4是不需要给你展示，所以他给你隐藏了

自己输出虚表中的地址

//VF_PTR也就是void(*)()
//void(*)()定义一个函数指针
typedef void(*VF_PTR)();

void PrintVFTable(VF_PTR* pTable)
{
    for(size_t i = 0; pTable[i] != 0; ++i)
    {
        printf("vfTable[%d]:%p\n", i, pTable[i]);
    }
}
int main()
{
    Base b;
    Derive d;
    PrintVfTable((VF_PTR*)((*int)&b));
    //取b的地址就是Base类型的地址
    //强转成int*就是取头4个字节
    //再*解引用就是取b上的四个字节
    //但是此时b是int类型，所以应该再强转一下
    //int类型+1就是4个字节
}
```
### 继承中虚表的概念
    如果是多继承，那我自己写的virtual虚函数会把地址放在第一个继承的虚表里面添加地址
    子类自己没有虚表
    多继承的子类有两个虚表，因为有两个父类
    同类型的对象指向同一个虚表

    内联函数为什么不能是虚函数？
    因为内联函数里面不能有地址,所以内联函数放不进虚表

    静态成员函数没有this指针
    而虚表是放进对象里面的
    所以静态的成员函数不能是虚函数

    一个类的不同对象共享该类的虚表

虚基表储存的是偏移量，是解决菱形继承的数据冗余和二义性的

- **通过实验可以发现,派生类和基类创建出来的对象的虚表地址不同,但是单一派生类对象中只有从基类继承下来的虚表**
- _vfptr后面的地址是指针本身的地址
- 不同类(基类,派生类)生成的虚表不一样
------
- 虚函数
  - 概念: 虚函数重写时多态的条件之一
  - 多态原理: 虚函数地址放到对象的虚表(虚函数表)中, 多态指向谁调用本质是运行到对象虚表找到调用的虚函数
- 虚继承
  - 概念: 解决菱形继承中的数据冗余和二义性
  - 原理: 将虚基类对象放到公共位置(VS是放到整个对象尾部), 虚基表中存偏移量,来计算虚基类对象的位置

总结: 记住这里两个地方都用virtual关键字,他们之间没有一点关联,不要联系到一起.